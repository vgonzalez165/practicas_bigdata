```
------------- ESPECIALIZACIÓN EN INTELIGENCIA ARTIFICIAL Y BIG DATA -------------
---------------------------------------------------------------------------------

Módulo:                     SISTEMAS DE BIG DATA
Profesor:                   Víctor J. González
Unidad de Trabajo:          UT02. Almacenamiento de datos
Práctica:                   PR0203: Estructuras de datos avanzadas
Resultados de aprendizaje:  RA3
```


# PR0203: Estructuras de datos avanzadas

En esta práctica vamos a desarrollar una aplicación en Python que gestione la información de jugadores y su clasificación en un torneo online, utilizando **Redis** como base de datos en memoria. El ejercicio combina **Hashes**, **Sorted Sets** y **HyperLogLog** para modelar distintos aspectos del sistema.

Imagina que trabajas en el backend de un **juego online multijugador**. Tu aplicación debe:

- Registrar jugadores.
- Actualizar sus puntuaciones tras cada partida.
- Mantener un ranking global.
- Calcular el número aproximado de jugadores únicos que se conectan diariamente (sin consumir demasiada memoria).

Para ello, utilizaremos las siguientes estructuras de datos:

| Tipo de dato Redis | Clave / Ejemplo          | Propósito                                                           |
| ------------------ | ------------------------ | ------------------------------------------------------------------- |
| **Hash**           | `player:<id>`            | Datos individuales de cada jugador (nombre, país, puntuación, etc.) |
| **Sorted Set**     | `leaderboard`            | Ranking global ordenado por puntuación                              |
| **HyperLogLog**    | `unique:players:<fecha>` | Conteo aproximado de jugadores únicos conectados cada día           |


## Tareas a realizar

Tienes que crear las siguientes funciones:

### Gestión de jugadores (Hash + Sorted Set)

**Función `add_player(id, name, country, score)`**

Crear el hash `player:<id>` con los campos:

  ```
  name, country, games_played, score
  ```
Insertar el jugador en el **sorted set** `leaderboard` con la puntuación inicial.


**Función `update_score(id, points)`**

Incrementa el campo `score` del jugador, actualiza,  su puntuación en el *sorted set* e incrementa el campo `games_played`.

**Función `player_info(id)`**

Muestra todos los datos almacenados en el hash `player:<id>`.

**Función `show_top_players(n)`**

Muestra los `n` mejores jugadores del ranking (`leaderboard`) con nombre, país y puntuación de cada jugador.



### Registro de actividad diaria (HyperLogLog)

**Función `register_login(player_id)`**

Cada vez que un jugador inicia sesión, añadir su ID al **HyperLogLog diario**.

Por ejemplo, para la fecha actual:

  ```
  key = f"unique:players:{fecha}"
  redis_client.pfadd(key, player_id)
  ```

**Función `count_unique_logins(date)`**

Obtiene el número aproximado de jugadores únicos que se conectaron ese día usando:

  ```
  redis_client.pfcount(key)
  ```

**Función `weekly_report(dates)`**

Dada una lista de fechas, calcula el total aproximado de jugadores únicos en toda la semana con:

  ```
  redis_client.pfmerge("unique:players:week", *keys)
  redis_client.pfcount("unique:players:week")
  ```


## Ejemplo de estructura esperada en Redis

```
leaderboard → sorted set
  101 (score=1200)
  102 (score=950)
  103 (score=1850)

player:101 → {name: "Ana", country: "España", games_played: 10, score: 1200}
player:102 → {name: "Luis", country: "México", games_played: 8, score: 950}
player:103 → {name: "Sofía", country: "Chile", games_played: 12, score: 1850}

unique:players:2025-10-14 → HyperLogLog con IDs de jugadores que se conectaron ese día
```


### Ampliaciones opcionales

- Registrar automáticamente la fecha actual del login con `datetime.date.today()`.
- Añadir control de errores si un jugador no existe.
- Implementar una función para reiniciar el ranking y las métricas (`reset_system()`).

