```
------------- ESPECIALIZACIÓN EN INTELIGENCIA ARTIFICIAL Y BIG DATA -------------
---------------------------------------------------------------------------------

Módulo:                     SISTEMAS DE BIG DATA
Profesor:                   Víctor J. González
Unidad de Trabajo:          UT02. Almacenamiento de datos
<<<<<<< HEAD
Práctica:                   PR0204: Escritura de datos en InfluxDB
Resultados de aprendizaje:  RA3
```


## Práctica: Monitorización de rendimiento del servidor con Python 

### Objetivo de la Práctica

En esta práctica aplicaremos los conocimientos de conexión, modelado de datos (`Point`) y escritura eficiente en lote (Batching) para crear un agente de monitorización que envíe métricas de un sistema operativo a InfluxDB.


### PARTE I: Obtención de métricas

Para esta práctica, utilizaremos la librería **`psutil`** para obtener las métricas de rendimiento de la máquina en la que se ejecuta el script.

El siguiente código muestra cómo obtener los porcentajes de uso de CPU y RAM, así como el total de RAM utilizada:

```python
import psutil
import time

# Obtener estadísticas de uso
def obtener_metricas_sistema(host_id):
    # Uso de CPU (promedio de los últimos segundos)
    cpu_usage = psutil.cpu_percent(interval=1)
    
    # Uso de RAM
    mem = psutil.virtual_memory()
    ram_used_gb = round(mem.used / (1024**3), 2) # Conversión a GB
    ram_percent = mem.percent
    
    # Uso de disco (en el punto de montaje raíz)
    disk = psutil.disk_usage('/')
    disk_percent = disk.percent
    
    return {
        'host': host_id,
        'cpu_percent': cpu_usage,
        'ram_used_gb': ram_used_gb,
        'ram_percent': ram_percent,
        'disk_percent': disk_percent
    }

# Ejemplo de uso:
# metrics = obtener_metricas_sistema("servidor_01")
# print(metrics)
```

### PARTE II: Modelado y escritura en lote

#### 1\. Diseño del modelo InfluxDB

El modelo debe asegurar que las métricas sean fáciles de consultar por máquina (host).

| Componente       | Clave                  | Valor de Ejemplo | Tipo en InfluxDB  |
| :--------------- | :--------------------- | :--------------- | :---------------- |
| **Measurement**  | `rendimiento_servidor` | Fijo             | Fijo              |
| **TAG**          | `host_id`              | `servidor_01`    | String (Indexado) |
| **TAG**          | `entorno`              | `produccion`     | String (Indexado) |
| **FIELD**        | `cpu_percent`          | `45.8`           | Float (Medición)  |
| **FIELD**        | `ram_percent`          | `82.1`           | Float (Medición)  |
| **FIELD**        | `disk_percent`         | `65.4`           | Float (Medición)  |

#### 2\. Tareas de Implementación

Desarrolla el script Python principal (`agente_monitoreo.py`) para:

1.  **Inicialización:** configurar el cliente y la `WriteAPI` en **modo Batching** (asíncrono) para optimizar el rendimiento.
2.  **Bucle de lectura:** crear un bucle infinito que:
    a. Llame a `obtener_metricas_sistema("servidor_A")` **cada segundo**.
    b. Construya un nuevo objeto `Point` por cada lectura, respetando el modelo de datos anterior.
    c. Use la `write_api.write()` para enviar el punto al buffer.
3.  **Cierre:** Asegurarse de que el script llama a `write_api.close()` antes de salir (p.ej., en una [excepción de teclado](https://www.geeksforgeeks.org/python/how-to-catch-a-keyboardinterrupt-in-python/)) para vaciar cualquier punto que quede en el buffer.
=======
Práctica:                   PR0204: Estructuras de datos avanzadas. Datos geoespaciales
Resultados de aprendizaje:  RA3
```

# PR0204: Estructuras de datos avanzadas: datos geoespaciales


Debes crear el *backend* para una aplicación de mapas, en concreto vas a implementar la funcionalidad de  "Buscador de Puntos de Interés (POI)".

Tu tarea es cargar en Redis una lista de ubicaciones (restaurantes, museos, parques, etc.) y luego crear scripts que permitan a un usuario encontrar los puntos más cercanos a él.

En Redis usarás una única clave de tipo `Sorted Set` (manejada con comandos GEO) para almacenar todas las ubicaciones.La clave se llamará `poi:locations`, almacenará la ubicación (longitud, latitud) de todos los puntos de interés y también un identificador único para el POI.

Además, necesitarás una segunda clave de tipo `Hash` que llamaremos `poi:info` para guardar la relación entre identificador y nombre del POI



## Tareas a desarrollar

### Tarea 1: Carga de datos

El objetivo de esta tareaa será poblar la base de datos Redis con los puntos de interés.

Los requisitos son:

1.  Crear un script `load_locations.py`.
2.  Utiliza la estructura de datos que está en el fichero [locations.py](./locations.py) con POIs de Madrid
3.  El script debe conectarse a Redis y, en un bucle:
        - **Añadir la ubicación:** usa `r.geoadd("poi:locations", (longitud, latitud, id))`
        - **Guardar el nombre:** usa `r.hset("poi:info", id, "Nombre del POI")`
4.  Imprimir un mensaje de "Datos cargados" al finalizar.


### Tarea 2: Búsqueda por radio

El objetivo de esta función es encontrar todos los POIs dentro de un radio específico desde la ubicación del usuario.
  
Los pasos a realizar son:

1.  Crea un script `find_by_radius.py(lat, lon, distance=2000)`.
2.  Define una ubicación de "Usuario" (p.ej., `lat=40.41677`, `lon=-3.70379`, que es la Puerta del Sol).
3.  Usa el comando `GEOSERACH` para encontrar todos los POIs en un radio.
4.  Para cada POI encontrado (que será un `id`) consulta el `HASH` `poi:info` para obtener su nombre.
5.  Imprime un informe: `Encontrados X POIs en 2 km:`
      - `-> Museo del Prado (id_001)`
      - `-> Palacio Real (id_003)`
  

### Tarea 3 (Opcional): Búsqueda del "más cercano"

El objetivo será encontrar el punto de interés *único* más cercano al usuario, sin importar la distancia.

Debes de:

1.  Crear un script `find_nearest.py(lat, lon)` que recogerá la ubicación del usuario.
2.  Usa el comando `GEOSERACH` para encontrar el POI **más cercano** (solo 1).
3.  Asegúrate de pedir también la **distancia**.
4.  Imprime el resultado: `El POI más cercano es "Nombre del POI", que está a X.XX km.`


**NOTA**: en [esta página](https://redis.io/docs/latest/develop/data-types/geospatial/) tienes la documentación sobre los comandos geoespaciales de Redis
>>>>>>> d530760c521f2a7e8df629324bdc07653aaf6901
